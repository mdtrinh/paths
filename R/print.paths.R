#####################################################
# Print method for paths objects
#####################################################

#' @param x a fitted model object returned by the \code{\link{paths}} function.
#' @rdname paths
#' @export
print.paths <- function(x, ...) {
  cat("\n")

  cat("Causal Paths Analysis \n\n")

  # Print function calll
  cat("Call: ")
  print(x$call)
  cat("\n")

  # Print model variables
  cat("Treatment:", x$varnames$a, "\n")
  cat("Outcome:", x$varnames$y, "\n\n")

  cat("Outcome model: ")
  print(x$formulas[[1]])
  cat("\n")

  K <- length(x$varnames$m)

  for(i in 1:K) {
    cat("Mediator", i, ": ", paste0(x$varnames$m[[i]], collapse = " + "), "\n")
  }
  cat("\n")

  # Print effect estimates
  cat("Causal Paths Estimates: \n\n")
  cat("Pure Imputation Estimator: \n")
  print(x$pure[,-1])
  cat("\n")
  if (!is.null(x$ps_formula)){
    cat("Imputation-based Weighting Estimator: \n")
    print(x$hybrid[,-1])
  }

  cat("\n")

  invisible(x)
}


#####################################################
# Summary method for paths objects
#####################################################
#' Summarizing Output from Causal Paths Analysis
#'
#' Function to report results from causal paths analysis. Report point estimates
#' and standard errors for the total effect, direct effect, and each individual
#' indirect effect, separately for Type I and Type II decomposition.
#'
#' @param object an object of class \code{paths} as generated by the
#'   \code{paths} function.
#' @param ... additional arguments (not yet implemented)
#'
#' @return An object of class \code{summary.paths}, which is a list containing
#'   the \code{call}, \code{varnames}, \code{formulas}, \code{classes}, ,
#'   \code{families}, \code{ps_formula}, \code{ps_class}, \code{ps_family},
#'   \code{nboot}, \code{conf_level} components from the \code{paths} object,
#'   plus \describe{ \item{nobs}{the number of observations.} \item{estimates}{a
#'   list containing four matrices, corresponding to effect estimates obtained
#'   using the pure imputation estimator and the imputation-based weighting
#'   estimator, with each of Type I and Type II decomposition. Each matrix
#'   contains the point estimates, standard errors and confidence intervals of
#'   the total effect, direct effect, and each individual indirect effect
#'   corresponding to the appropriate decomposition. The elements in each matrix
#'   are extracted from the \code{paths} object. } }
#'
#' @details \code{print.summary.paths} tries to smartly format the point
#'   estimates and confidence intervals, and provides 'signficance stars'
#'   through the \code{stats::printCoefmat} function.
#'
#'   It also prints out the names of the outcome, treatment, mediator and
#'   covariate variables as extracted from the \code{formulas} argument of the
#'   call to \code{paths} for users to verify if the model formulas have been
#'   correctly specified.
#'
#' @inherit paths seealso author
#'
#' @aliases print.summary.paths
#' @export
summary.paths <- function(object, ...){

  call <- object$call
  varnames <- object$varnames
  formulas <- object$formulas
  classes <- object$classes
  families <- object$families
  ps_formula <- object$ps_formula
  ps_class <- object$ps_class
  ps_family <- object$ps_family
  nobs <- nrow(object$data)
  nboot <- object$nboot
  conf_level <- object$conf_level

  clp <- 100*conf_level

  # Extract 4 separate tables
  estimates_pure_t1 <- object$pure[object$pure$decomposition == "Type I", -c(1,2,3)]
  estimates_pure_t2 <- object$pure[object$pure$decomposition == "Type II", -c(1,2,3)]
  estimates_hybrid_t1 <- object$hybrid[object$hybrid$decomposition == "Type I", -c(1,2,3)]
  estimates_hybrid_t2 <- object$hybrid[object$hybrid$decomposition == "Type II", -c(1,2,3)]

  rownames(estimates_pure_t1) <-
    rownames(estimates_pure_t2) <-
    rownames(estimates_hybrid_t1) <-
    rownames(estimates_hybrid_t2) <-
    c("Total Effect", "Direct Effect",
      sapply(length(varnames$m):1,
             function(k) paste("T -> Mediator", k, "->> Y")))

  colnames(estimates_pure_t1) <-
    colnames(estimates_pure_t2) <-
    colnames(estimates_hybrid_t1) <-
    colnames(estimates_hybrid_t2) <-
    c("Estimate",
      "Std. Err.",
      paste(clp, "% CI Lower", sep=""),
      paste(clp, "% CI Upper", sep=""),
      "P-value")

  estimates <- if(!is.null(object$ps_formula)) {
    list(pure_t1 = estimates_pure_t1,
         pure_t2 = estimates_pure_t2,
         hybrid_t1 = estimates_hybrid_t1,
         hybrid_t2 = estimates_hybrid_t2)
  } else {
    list(pure_t1 = estimates_pure_t1,
         pure_t2 = estimates_pure_t2)
  }

  out <- list(call = call,
              varnames = varnames,
              formulas = formulas,
              classes = classes,
              ps_formula = ps_formula,
              ps_class = ps_class,
              nobs = nobs,
              nboot = nboot,
              conf_level <- conf_level,
              estimates = estimates)

  class(out) <- "summary.paths"

  return(out)
}

#' @param x an object of class \code{summary.paths}
#' @rdname summary.paths
#' @export
print.summary.paths <- function(x, ...) {

  clp <- 100*x$conf_level

  cat("\n")

  cat("Causal Paths Analysis \n\n")

  # Print function calll
  cat("Call: ")
  print(x$call)
  cat("\n")

  # Print model variables
  cat("Treatment:", x$varnames$a, "\n")
  cat("Outcome:", x$varnames$y, "\n\n")

  cat("Outcome model: ")
  print(x$formulas[[1]])
  cat("\n")

  K <- length(x$varnames$m)

  for(i in 1:K) {
    cat("Mediator", i, ": ", paste0(x$varnames$m[[i]], collapse = " + "), "\n")
  }
  cat("\n")

  # Print output table

  # Print effect estimates
  cat("Causal Paths Estimates: \n\n")

  cat("Pure Imputation Estimator: \n")
  # Use the printCoefmat() function to conveniently generate
  # summary table
  # Note the use of test statistic-like format
  # (through tst.ind and dig.test) for Estimate and CIs columns
  cat("Type 1 Decomposition: \n")
  printCoefmat(x$estimates$pure_t1,
               digits = 2,
               P.values = TRUE,
               tst.ind = 1:3,
               dig.tst = 3,
               has.Pvalue = TRUE)

  cat("\n")
  cat("Type 2 Decomposition: \n")
  printCoefmat(x$estimates$pure_t2,
               digits = 2,
               P.values = TRUE,
               tst.ind = 1:3,
               dig.tst = 3,
               has.Pvalue = TRUE)
  cat("\n\n")
  if (!is.null(x$ps_formula)){
    cat("Imputation-based Weighting Estimator: \n")
    cat("Type 1 Decomposition: \n")
    printCoefmat(x$estimates$hybrid_t1,
                 digits = 2,
                 P.values = TRUE,
                 tst.ind = 1:3,
                 dig.tst = 3,
                 has.Pvalue = TRUE)

    cat("\n")
    cat("Type 2 Decomposition: \n")
    printCoefmat(x$estimates$hybrid_t2,
                 digits = 2,
                 P.values = TRUE,
                 tst.ind = 1:3,
                 dig.tst = 3,
                 has.Pvalue = TRUE)
    cat("\n\n")
  }

  # TK Check if this is still relevant

  # cat("\n")
  # if(x$conditional){
  #   cat("Total Effect calculated conditional on covariates \n")
  # } else {
  #   cat("Total Effect calculated unconditionally \n")
  # }
  #
  # cat("\n\n")

  cat("Sample size:", x$nobs,"\n\n")
  cat("Number of bootstrap simulations:", x$nboot,"\n\n")

  invisible(x)
}
